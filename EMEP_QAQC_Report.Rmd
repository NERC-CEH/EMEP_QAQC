---
title: "EMEP QAQC Report"
output:
  rmdformats::readthedown:
    toc_depth: 3
    fig_width: 10
---

```{r setup, include=FALSE}
library(knitr)
library(ncmeta)
library(tidync)
library(tidyverse)
library(fs)
library(sf)
library(lubridate)
library(furrr)
library(stars)
library(ncdf4)
library(ncdf4.helpers)
library(openair)
library(ggpubr)
library(gridExtra)
library(ggh4x)
library(rnaturalearth)
library(textclean)
library(gt)
library(leaflet)
library(logger)
library(htmltools)
source('emep_qaqc_user_input.R')
source('myquicktext.R')
source('emep_vars_parameters.R')
source('emep_qaqc_funcs.R')

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.align = 'center')
knit_engines$set(asis = function(options) {
  if (options$echo && options$eval) knit_child(text = options$code)
})

VAR_PARAMS_LIST = get_params_list() # list of parameters for each EMEP var 
OBS_VAR_PARAMS_LIST = get_obs_var_params_list() # list of plotting params for EMEP vars used in obs-mod comparison

## create a table of observed species and their equivalent emep vars
gt_var_labeller = c(no = 'NO',
                    no2 = 'NO[2]',
                    o3 = 'O[3]',
                    ox = 'O[x]',
                    `ox(ppb)` = 'O[x] (ppb)',
                    nox = 'NO[x]',
                    nh3 = 'NH[3]',
                    sox = 'SO[x]',
                    so2 = 'SO[2]',
                    voc = 'VOC',
                    co = 'CO',
                    pm2.5 = 'PM[2.5]',
                    pm25 = 'PM[2.5]',
                    pmco = 'PM[Coarse]',
                    pm10 = 'PM[10]')

MODSTATS_STATS_LOOKUP = c(n = 'Count',
                          FAC2 = 'Factor of Two',
                          MB = 'Mean Bias',
                          NMB = 'Normalised Mean Bias',
                          RMSE = 'Root Mean Squared Error',
                          r = 'Correlation Coefficient')

USERS = c(tomlis65 = 'Tomas Liska',
          mvi = 'Massimo Vieno',
          jansch = 'Janice Scheffler',
          yuawan = 'Yuanlin Wang',
          racbec = 'Rachel Beck',
          liqyao = 'Liquan Yao',
          damtan = 'Damaris Tan')

#initiate chunk params (crashes without it)
emiss_exceedance_tbls = list(NULL, NULL)
MBS_list = list()
emiss_list = list()
MBS_exceedance_tbls = list(NULL,NULL)
v_tbl2 = NULL
budget_exceed_tbl = tibble()
domain_dims = c(1,1)
both_stats = tibble()

#clean report_out_pth for new log and initiate new log file
archive_log(logger_pth)
log_appender(appender_file(logger_pth))

#set for parallel processing
future::plan(multicore)
```


```{r run info, echo = F}
#log
log_with_separator('Run Info Summary', separator = '-')
log_layout(layout_glue)

test_run_info = c(na.omit(c(TEST_INNER_DIR, TEST_OUTER_DIR))) %>% 
  path_common()

ref_run_info = c(na.omit(c(REF_INNER_DIR, REF_OUTER_DIR))) %>% 
    path_common()

inner_domain = path_split(TEST_INNER_DIR) %>% 
  map_chr(last)
outer_domain = path_split(TEST_OUTER_DIR) %>% 
  map_chr(last)

EMEP_domains = c(outer_domain, inner_domain)

log_info('Test run directory: {test_run_info}')
log_info('Reference run directory: {ref_run_info}')
if (is.na(outer_domain)) {
  log_warn('Outer domain not submitted for this QAQC')
} else {
  log_info('Outer domain: {outer_domain}')
}

if (is.na(inner_domain)) {
  log_warn('Inner domain not submitted for this QAQC')
} else {
  log_info('Inner domain: {inner_domain}')
}

#determine author of the qaqc run
qaqc_user = QAQC_DIR %>%
  path_split() %>% 
  list_c() %>% 
  .[str_which(.,'home') + 1] %>% 
  USERS[.]

if (is.na(qaqc_user)) {
  log_error('User not defined in USERS, please update USERS in EMEP_QAQC_Report.Rmd.')
  stop('User not defined in USERS, please update USERS in EMEP_QAQC_Report.Rmd.')
}

log_layout(layout_blank)
log_separator(separator = ' ')
log_separator(separator = ' ')
```
The report has been produced by **`r qaqc_user`**. All outputs have been saved in **`r QAQC_DIR`.**

# Run Info

**Test Run Directory:** `r test_run_info`
\
**Reference Run Directory:** `r ref_run_info`
``` {asis, echo = !is.na(outer_domain), eval = !is.na(outer_domain)}
**Outer Domain:** `r outer_domain`
```
``` {asis, echo = is.na(outer_domain), eval = is.na(outer_domain)}
**Outer Domain:** Not submitted for this QA/QC
```
``` {asis, echo = !is.na(inner_domain), eval = !is.na(inner_domain)}
**Inner Domain:** `r inner_domain`
```
``` {asis, echo = is.na(inner_domain), eval = is.na(inner_domain)}
**Inner Domain:** Not submitted for this QA/QC
```

# File Size
```{r file_size_check, eval = COMPARE_FILE_SIZE}

log_layout(layout_glue)
log_with_separator('COMPARE_FILE_SIZE task', separator = '-')

fsize_tables = map2(c(TEST_OUTER_DIR, TEST_INNER_DIR),
                c(REF_OUTER_DIR, REF_INNER_DIR), 
                safely(compare_file_size)) %>% 
  transpose() %>% 
  .$result %>% 
  map(safely(format_file_size_table)) %>% 
  transpose() %>% 
  .$result
```

``` {asis, echo = all(!is.na(c(outer_domain, inner_domain))) && COMPARE_FILE_SIZE, eval = all(!is.na(c(outer_domain, inner_domain))) && COMPARE_FILE_SIZE}
## `r outer_domain` Domain
```
``` {r, eval = !is.na(outer_domain) && COMPARE_FILE_SIZE, results = 'asis'}
fsize_tables[[1]]
```
``` {asis, echo = all(!is.na(c(outer_domain, inner_domain))) && COMPARE_FILE_SIZE, eval = all(!is.na(c(outer_domain, inner_domain))) && COMPARE_FILE_SIZE}
## `r inner_domain` Domain
```
``` {r, eval = !is.na(inner_domain) && COMPARE_FILE_SIZE, results = 'asis'}
fsize_tables[[2]]
```

```{r, eval = COMPARE_FILE_SIZE}
log_success('!!!COMPARE_FILE_SIZE task completed!!!')
log_layout(layout_blank)
log_separator(separator = ' ')
log_separator(separator = ' ')
```

```{r Inventory_emission_check, eval = COMPARE_EMISSIONS}
log_layout(layout_glue)
log_with_separator('COMPARE_EMISSIONS task', separator = '-')

if (!is.null(EMISSION_INVENTORY_PTH)) {
  log_info('Emission inventory path: {path_abs(EMISSION_INVENTORY_PTH)}')
  emiss_list0 = map(c(TEST_OUTER_DIR, TEST_INNER_DIR), safely(compare_inv_mod_emissions), emiss_inv_pth = EMISSION_INVENTORY_PTH) %>%
    transpose()

  emiss_is_ok = emiss_list0$error %>% 
    map_lgl(is_null)
  
  #logger
  if (!is.null(TEST_OUTER_DIR)) {
    if (emiss_is_ok[1]) {
      log_info('Model vs Inventory emission comparison for {outer_domain} domain SUCCESSFUL')
    } else {
      log_error('Model vs Inventory emission comparison for {outer_domain} domain FAILED' )
      log_debug(emiss_list0$error[[1]])
    }
  }
  
  if (!is.null(TEST_INNER_DIR)) {
    if (emiss_is_ok[2]) {
      log_info('Model vs Inventory emission comparison for {inner_domain} domain SUCCESSFUL')
    } else {
      log_error('Model vs Inventory emission comparison for {inner_domain} domain FAILED' )
      log_debug(emiss_list0$error[[2]])
    }
  }
  
  emiss_list = emiss_list0$result[emiss_is_ok]
  
  if (length(emiss_list) > 0) {
    
    #determine the number of plots per page so that they fit on A4 paper
    n_land = map_int(emiss_list, ~n_distinct(.x$Land))
    ppp = map_int(n_land, ~case_when(.x <=10 ~ 4L,
                                     .x >= 11 && .x <= 20 ~ 2L,
                                     .x > 20 ~ 1L))
    
    emiss_plot_list = map(emiss_list, plot_emiss_diff, threshold = EMISS_DIFF_THRESHOLD)
    
    page_titles = str_c(c(TEST_OUTER_DIR, TEST_INNER_DIR)[emiss_is_ok], '\n\n')
    
    emiss_plots_arranged = pmap(list(grobs = emiss_plot_list, nrow = ppp, top = page_titles),
                                marrangeGrob, ncol = 1)
    out_pths = path(plots_pth_out, str_c(EMEP_domains[emiss_is_ok], '_', INV_MOD_EMISS_PLOT_FNAME))
    
    walk2(emiss_plots_arranged, out_pths, ~ggsave(filename = .y, plot = .x,paper = 'a4', height = 10, width = 7))
    
    log_info('Model vs Inventory emission check plots SAVED')
    
  }
  
    #filter only those over threshold

  emiss_exceedance_tbls = emiss_list0$result %>%
    map(safely(filter), rel_diff > EMISS_DIFF_THRESHOLD) %>% 
    transpose() %>%
    .$result %>% 
    map(check_nrow)
  
  emiss_exceedance_tbls_fmted = emiss_exceedance_tbls %>% 
    map(safely(format_inv_table)) %>%
    transpose() %>% 
    .$result
  } else {
    log_warn('Emission inventory path: {EMISSION_INVENTORY_PTH}. Model vs Inventory emission check NOT POSSIBLE.')
  }

```

```{r MBS_emission_check, eval = COMPARE_EMISSIONS}
###MassBudgetSummary.txt data
MBS_list0 = map2(c(TEST_OUTER_DIR, TEST_INNER_DIR), 
                c(REF_OUTER_DIR, REF_INNER_DIR), 
                safely(compare_run_emissions), save_file = T, mbs_table_fname = MBS_TABLE_FNAME) %>% 
  transpose()

MBS_is_ok = MBS_list0$error %>% 
  map_lgl(is_null)

  #logger
  if (!is.null(TEST_OUTER_DIR)) {
    if (MBS_is_ok[1]) {
      log_info('Test vs Reference run emission comparison for {outer_domain} domain SUCCESSFUL')
    } else {
      log_error('Test vs Reference run emission comparison for {outer_domain} domain FAILED' )
      log_debug(MBS_list0$error[[1]])
    }
  }
  
  if (!is.null(TEST_INNER_DIR)) {
    if (MBS_is_ok[2]) {
      log_info('Test vs Reference run emission comparison for {inner_domain} domain SUCCESSFUL')
    } else {
      log_error('Test vs Reference run emission comparison for {inner_domain} domain FAILED' )
      log_debug(MBS_list0$error[[2]])
    }
  }

MBS_list = MBS_list0$result[MBS_is_ok]

MBS_plot_captions = c(str_c('Test: ', path(TEST_OUTER_DIR, 'MassBudgetSummary.txt'),'\n',
                            'Ref: ', path(REF_OUTER_DIR, 'MassBudgetSummary.txt')),
                      str_c('Test: ', path(TEST_INNER_DIR, 'MassBudgetSummary.txt'),'\n',
                            'Ref: ', path(REF_INNER_DIR, 'MassBudgetSummary.txt'))) %>% 
  na.omit()

if (length(MBS_list) > 0) {
  MBS_plots = map(MBS_list, plot_MBS_diff, threshold = EMISS_DIFF_THRESHOLD) %>%
  map2(MBS_plot_captions, ~.x + labs(caption = .y) + theme(plot.caption = element_text(size = 6, face = 'italic') ))


  walk2(MBS_plots, path(plots_pth_out, str_c(na.omit(EMEP_domains), '_', MBS_PLOT_FNAME)),
        ~ggsave(.y, plot = .x, width = 7, height = 7))
  
  log_info('Test vs Reference run emission check plots SAVED')
  }

```

```{r MBS_check_report, eval = COMPARE_EMISSIONS}
#for report filter only those over emission threshold

MBS_exceedance_tbls = MBS_list0$result %>%
  map(safely(filter), rel_diff > EMISS_DIFF_THRESHOLD) %>% 
  transpose() %>%
  .$result %>% 
  map(check_nrow)

MBS_exceedance_tbls_fmted = MBS_exceedance_tbls %>% 
  map(safely(format_MBS_table)) %>%
  transpose() %>% 
  .$result
```

``` {asis, echo = COMPARE_EMISSIONS, eval = COMPARE_EMISSIONS}
# Emissions 
```

``` {asis, echo = COMPARE_EMISSIONS && is.null(EMISSION_INVENTORY_PTH), eval = COMPARE_EMISSIONS}
An emission inventory file not supplied. A comparison between model and inventory emissions is not available. 
```

``` {asis, echo = COMPARE_EMISSIONS && !is.null(EMISSION_INVENTORY_PTH) && length(emiss_list) == 0, eval = COMPARE_EMISSIONS}
A comparison between the supplied inventory file and the test run emissions is currently not possible. 
```
``` {asis, echo = all(!is.na(c(outer_domain, inner_domain))), eval = COMPARE_EMISSIONS}
## `r outer_domain` Domain
```

``` {asis, echo = COMPARE_EMISSIONS && !is.na(outer_domain) && is.null(emiss_exceedance_tbls[[1]] ) && !is.null(EMISSION_INVENTORY_PTH) && length(emiss_list) != 0 , eval = COMPARE_EMISSIONS && !is.na(outer_domain) && is.null(emiss_exceedance_tbls[[1]] ) && !is.null(EMISSION_INVENTORY_PTH)}
All test run emissions are within `r EMISS_DIFF_THRESHOLD`% of those in the supplied emission inventory file.
```

``` {asis, echo = COMPARE_EMISSIONS && !is.na(outer_domain) && !is.null(emiss_exceedance_tbls[[1]]) && !is.null(EMISSION_INVENTORY_PTH), eval = COMPARE_EMISSIONS && !is.na(outer_domain) && !is.null(emiss_exceedance_tbls[[1]]) && !is.null(EMISSION_INVENTORY_PTH)}
Emissions of the following species in the test run differ by more than `r EMISS_DIFF_THRESHOLD`% from those in the supplied emission inventory file:
```

``` {r, eval = COMPARE_EMISSIONS && !is.na(outer_domain) && !is.null(emiss_exceedance_tbls[[1]]) && !is.null(EMISSION_INVENTORY_PTH)}
emiss_exceedance_tbls_fmted[[1]]
log_info('Model vs Inventory emission differences exceeding the {EMISS_DIFF_THRESHOLD}% threshold for {outer_domain} domain printed in report')
```

``` {asis, echo = COMPARE_EMISSIONS && length(MBS_list) == 0, eval = COMPARE_EMISSIONS}
A comparison between test and reference run emissions for the supplied runs is currently not available. 
```
``` {asis, echo = COMPARE_EMISSIONS && !is.na(outer_domain) && is.null(MBS_exceedance_tbls[[1]] ) && length(MBS_list) != 0, eval = COMPARE_EMISSIONS && !is.na(outer_domain) && is.null(MBS_exceedance_tbls[[1]] ) && length(MBS_list) != 0}
All test run emissions are within `r EMISS_DIFF_THRESHOLD`% of those in the reference run.
```

``` {asis, echo = COMPARE_EMISSIONS && !is.na(outer_domain) && !is.null(MBS_exceedance_tbls[[1]]) && length(MBS_list) != 0, eval = COMPARE_EMISSIONS && !is.na(outer_domain) && !is.null(MBS_exceedance_tbls[[1]]) && length(MBS_list) != 0}
Emissions of the following species in the test run differ by more than `r EMISS_DIFF_THRESHOLD`% from those in the reference run:
```

``` {r, eval = COMPARE_EMISSIONS && !is.na(outer_domain) && !is.null(MBS_exceedance_tbls[[1]]) && length(MBS_list) != 0}
MBS_exceedance_tbls_fmted[[1]]
log_info('Test vs reference emission differences exceeding the {EMISS_DIFF_THRESHOLD}% threshold for {outer_domain} domain printed in report')
```

``` {asis, echo = all(!is.na(c(outer_domain, inner_domain))), eval = COMPARE_EMISSIONS}
## `r inner_domain` Domain
```

``` {asis, echo = COMPARE_EMISSIONS && !is.na(inner_domain) && is.null(emiss_exceedance_tbls[[2]]) && !is.null(EMISSION_INVENTORY_PTH) && length(emiss_list) != 0, eval = COMPARE_EMISSIONS && !is.na(inner_domain) && is.null(emiss_exceedance_tbls[[2]]) && !is.null(EMISSION_INVENTORY_PTH)}
All test run emissions are within `r EMISS_DIFF_THRESHOLD`% of those in the supplied emission inventory file.
```

``` {asis, echo = COMPARE_EMISSIONS && !is.na(inner_domain) && !is.null(emiss_exceedance_tbls[[2]]) && !is.null(EMISSION_INVENTORY_PTH), eval = COMPARE_EMISSIONS && !is.na(inner_domain) && !is.null(emiss_exceedance_tbls[[2]]) && !is.null(EMISSION_INVENTORY_PTH)}
Emissions of the following species in the test run differ by more than `r EMISS_DIFF_THRESHOLD`% from those in the supplied emission inventory file:
```

``` {r, eval = COMPARE_EMISSIONS && !is.na(inner_domain) && !is.null(emiss_exceedance_tbls[[2]]) && !is.null(EMISSION_INVENTORY_PTH)}
emiss_exceedance_tbls_fmted[[2]]
log_info('Model vs Inventory emission differences exceeding the {EMISS_DIFF_THRESHOLD}% threshold for {inner_domain} domain printed in report')
```

``` {asis, echo = COMPARE_EMISSIONS && !is.na(inner_domain) && is.null(MBS_exceedance_tbls[[2]] ) && length(MBS_list) != 0, eval = COMPARE_EMISSIONS && !is.na(inner_domain) && is.null(MBS_exceedance_tbls[[2]] ) && length(MBS_list) != 0}
All test run emissions are within `r EMISS_DIFF_THRESHOLD`% of those in the reference run.
```

``` {asis, echo = COMPARE_EMISSIONS && !is.na(inner_domain) && !is.null(MBS_exceedance_tbls[[2]]) && length(MBS_list) != 0, eval = COMPARE_EMISSIONS && !is.na(inner_domain) && !is.null(MBS_exceedance_tbls[[2]]) && length(MBS_list) != 0}
Emissions of the following species in the test run differ by more than `r EMISS_DIFF_THRESHOLD`% from those in the reference run:
```

``` {r, eval = COMPARE_EMISSIONS && !is.na(inner_domain) && !is.null(MBS_exceedance_tbls[[2]]) && length(MBS_list) != 0}
MBS_exceedance_tbls_fmted[[2]]
log_info('Test vs reference emission differences exceeding the threshold for {inner_domain} domain printed in report')
```

```{r, eval = COMPARE_EMISSIONS}
log_success('!!!COMPARE_EMISSIONS task completed!!!')
log_layout(layout_blank)
log_separator(separator = ' ')
log_separator(separator = ' ')
```

``` {asis, echo = COMPARE_BUDGET_MSC, eval = COMPARE_BUDGET_MSC}
# Budget & Mean Surface Concentrations (MSC)
```

```{r budget, eval = COMPARE_BUDGET_MSC, results = 'hide'}
log_layout(layout_glue)
log_with_separator('COMPARE_BUDGET_MSC task', separator = '-')

#WIP - this needs to have some checks in case TEST_INNER_DIR is accidentally not used
EMEP_BUDGET_FNAME = map_chr(EMEP_BUDGET_DIR, ~dir_ls(.) %>%
                              str_subset('fullrun'))

emep_budget_vars = select_vars(vars = BUDGET_VARS, var_params_list = VAR_PARAMS_LIST, param = 'budg_factor') 
emep_budget = map2(EMEP_BUDGET_FNAME, EMEP_BUDGET_CRS, ~read_emep(.x, .y, var = emep_budget_vars, proxy = F))

#get test file modelled year to put into output filename
mod_test_year = EMEP_BUDGET_FNAME[1] %>%
  read_stars(sub = names(emep_budget[[1]])[1]) %>%
  st_get_dimension_values('time') %>% 
  year()

if (!is.null(BUDGET_MASK_FNAME)) {
  budget_mask = st_read(BUDGET_MASK_FNAME)
  log_info('Budget mask path: {path_abs(BUDGET_MASK_FNAME)}')
  
  emep_budget2 = tryCatch(
    error = function(cnd) {
      emep_budget
      log_warn('FAILED to apply area mask. Budget calculated for the full modelling domain.')
      log_debug(cnd)
    },
    emep_budget %>%
      map(apply_area_mask, area_mask = budget_mask)
  )
} else {
  emep_budget2 = emep_budget
  log_warn('Budget mask path: {BUDGET_MASK_FNAME}. Budget calculated for the full modelling domain.')
}
emep_budget2 = emep_budget2 %>% 
  set_names(nm = EMEP_BUDGET_FNAME)
budget_df = map_dfr(emep_budget2, calc_budget, VAR_PARAMS_LIST, .id = 'run') %>% 
  arrange(Variable) %>% 
  mutate(run = str_replace(run, '_[^_]+$', '')) %>% #drop characters after the last underscore (e.g. 'fullrun.nc')
  write_csv(path(tables_pth_out, paste0(path_ext_remove(BUDGET_TABLE_FNAME), '_', mod_test_year,
                                        '.', path_ext(BUDGET_TABLE_FNAME))))
log_info('Budget table SAVED')

#plot the difference if comparing two budget files
if (length(EMEP_BUDGET_FNAME) == 2) {
  budget_df2 = budget_df %>%
    mutate(run2 = if_else(run == str_replace(EMEP_BUDGET_FNAME[1], '_[^_]+$', ''), 'test', 'ref')) %>% 
    pivot_longer(cols = any_of(c('Total', 'Mean')), names_to = 'Stat', values_to = 'value') %>%
    pivot_wider(id_cols = c(Variable, Stat, Unit), names_from = run2, values_from = value) %>% 
    drop_na() %>% 
    mutate(abs_diff = test - ref,
           rel_diff = abs_diff/ref*100)

  budget_plot = plot_budget_diff(budget_df2, threshold = BUDGET_DIFF_THRESHOLD)
  if (is.null(budget_plot)) {
    log_info('Budgets for both runs are identical. Budget difference plots not produced.')
  } else {
    ggsave(path(plots_pth_out, BUDGET_PLOT_FNAME), height = 10, width = 7, type = 'cairo')
    log_info('Budget difference plots SAVED')
  }
  
  #for report
  v_tbl = categorise_emep_vars(budget_df2$Variable)
  v_tbl2 = v_tbl %>% 
    gt() %>% 
    sub_missing(columns = everything(), missing_text = '') %>% 
    cols_label(emiss_vars = 'Emission Vars',
               surf_vars = 'Surface Conc Vars',
               dep_vars = 'Deposition Vars',
               misc_vars = 'Other Vars') %>% 
    tab_options(data_row.padding = px(3),
                #table.font.size = pct(95),
                table.align='left')
  
  budget_exceed_tbl = budget_df2 %>% 
    filter(rel_diff > BUDGET_DIFF_THRESHOLD)
  
  if (nrow(budget_exceed_tbl != 0)) {
    budget_exceed_tbl2 = budget_exceed_tbl %>%
      select(Variable, rel_diff) %>%
      gt() %>% 
      tab_style(style = list(cell_text(color = 'red')),
                locations = cells_body(columns = rel_diff)) %>% 
      cols_label(rel_diff = 'Difference (%)') %>% 
      cols_align(align = 'right',
                 columns = rel_diff) %>% 
      fmt_number(columns = rel_diff, decimals = 1) %>% 
      tab_options(data_row.padding = px(3),
                  #table.font.size = pct(95),
                  table.align='left')
  } 
  
}

# #plot only the test run (the first element in EMEP_BUDGET_FNAME)
dsc_plots = plot_DSC(emep_budget2[[1]], VAR_PARAMS_LIST)

page_titles = format_maps_page_title(inner_test_pth = EMEP_BUDGET_FNAME[1], run_labels = 'EMEP run') %>%
  rep(length(dsc_plots))
export = marrangeGrob(grobs = dsc_plots, nrow = 1, ncol = 1, top = substitute(page_titles[g]))
ggsave(filename = path(maps_pth_out, DSC_MAPS_FNAME), export, paper = 'a4', height = 10, width = 7)
log_info('Budget maps in pdf format SAVED')

rm(dsc_plots, emep_budget2, export)
  
```

``` {asis, echo = COMPARE_BUDGET_MSC && !is.null(BUDGET_MASK_FNAME) && !is.null(v_tbl2), eval = COMPARE_BUDGET_MSC}
Budget or MSC have been calculated and compared with the reference run using the area mask file **`r BUDGET_MASK_FNAME`** for the following EMEP variables:
```

``` {asis, echo = COMPARE_BUDGET_MSC && is.null(BUDGET_MASK_FNAME) && !is.null(v_tbl2), eval = COMPARE_BUDGET_MSC}
Budget or MSC have been calculated and compared with the reference run using the full domain of the **`r EMEP_BUDGET_FNAME[1]`** file for the following EMEP variables:
```

``` {r, eval = COMPARE_BUDGET_MSC && !is.null(v_tbl2)}
v_tbl2
log_info('Variables in Test vs Reference budget check printed in a table in the report')
```

``` {asis, echo = COMPARE_BUDGET_MSC && !is.null(v_tbl2) && nrow(budget_exceed_tbl) == 0, eval = COMPARE_BUDGET_MSC}
The budget or MSC for all the above variables in the test run is within `r BUDGET_DIFF_THRESHOLD`% of the corresponding values in the reference run.
```

``` {asis, echo = COMPARE_BUDGET_MSC && !is.null(v_tbl2) && !nrow(budget_exceed_tbl) == 0, eval = COMPARE_BUDGET_MSC}
The difference in budget (or MSC) between the test and reference runs is larger than `r BUDGET_DIFF_THRESHOLD`% for the following variables:
```

``` {r, eval = COMPARE_BUDGET_MSC && !nrow(budget_exceed_tbl) == 0}
budget_exceed_tbl2
log_info('Variables in Test vs Reference budget check exceeding the {BUDGET_DIFF_THRESHOLD}% threshold printed in a table in the report')
```

```{r, eval = COMPARE_BUDGET_MSC}
log_success('!!!COMPARE_BUDGET_MSC task completed!!!')
log_layout(layout_blank)
log_separator(separator = ' ')
log_separator(separator = ' ')
```

``` {asis, echo = PLOT_COMPARISON_MAPS, eval = PLOT_COMPARISON_MAPS}
# Comparison Maps
```

```{r comparison_maps, eval = PLOT_COMPARISON_MAPS, include=FALSE}
log_layout(layout_glue)
log_with_separator('PLOT_COMPARISON_MAPS task', separator = '-')

if (FULLRUN_OUTER_TRIMMED == T) {
  log_warn('Trimmed outer run fullrun file used!')
  outer_file_tag = 'fulltrimmed'
} else {
  outer_file_tag = 'fullrun'
}

if (FULLRUN_INNER_TRIMMED == T) {
  log_warn('Trimmed inner run fullrun file used!')
  inner_file_tag = 'fulltrimmed'
} else {
  inner_file_tag = 'fullrun'
}

#collate emep_vars
comp_map_vars = select_vars(vars = COMP_MAP_VARS, var_params_list = VAR_PARAMS_LIST, param = 'map_levs')

comp_map_data = future_map(comp_map_vars, ~calculate_emep_diff(emep_var = .x,
                                                               run_labels = RUN_LABELS,
                                                               outer_test_fname = select_file_from_dir(TEST_OUTER_DIR, fname = outer_file_tag),
                                                               outer_ref_fname = select_file_from_dir(REF_OUTER_DIR, fname = outer_file_tag),
                                                               inner_test_fname = select_file_from_dir(TEST_INNER_DIR, fname = inner_file_tag),
                                                               inner_ref_fname = select_file_from_dir(REF_INNER_DIR, fname = inner_file_tag),
                                                               test_crs = TEST_CRS, ref_crs = REF_CRS ), .options = furrr_options(seed = T))

null_vars_lgl = comp_map_data %>% 
  map_lgl(is_null)
null_vars = comp_map_vars[null_vars_lgl]

comp_map_data = comp_map_data[!null_vars_lgl]

if (length(comp_map_data) > 0) {
  log_info('Data for comparison maps collated')
} else {
  log_error('Data for comparison maps FAILED to collate')
}

comp_plots_list = future_map(comp_map_data, plot_comp_maps, ncl_palette_dir = PALETTE_DIR, pretty_lab = PRETTY_LABS, .options = furrr_options(seed = T)) %>% 
  set_names(comp_map_vars[!null_vars_lgl])
log_info('Comparison maps for {names(comp_plots_list)} created')

page_titles = format_maps_page_title(outer_test_pth = select_file_from_dir(TEST_OUTER_DIR, fname = outer_file_tag),
                                     outer_ref_pth = select_file_from_dir(REF_OUTER_DIR, fname = outer_file_tag),
                                     inner_test_pth = select_file_from_dir(TEST_INNER_DIR, fname = inner_file_tag),
                                     inner_ref_pth = select_file_from_dir(REF_INNER_DIR, fname = inner_file_tag),
                                     run_labels = str_c(RUN_LABELS, ' run')) %>%
  rep(length(comp_plots_list))

if (all(!map_lgl(list(TEST_INNER_DIR, REF_INNER_DIR, TEST_OUTER_DIR, REF_OUTER_DIR), is.null))) {
  #plot inner domain only if both outer and inner data provided
  comp_map_data_i = future_map(comp_map_data,  ~.x[matches('inner', vars = names(.x))], .options = furrr_options(seed = T))
  comp_plots_list_i = future_map(comp_map_data_i, plot_comp_maps, ncl_palette_dir = PALETTE_DIR, pretty_lab = PRETTY_LABS, .options = furrr_options(seed = T)) %>% 
    #add 'i' suffix to names to distinguish just inner domain plots
    set_names(str_c(comp_map_vars[!null_vars_lgl], 'i', sep = '_'))
  
  log_info('Comparison maps plotlist for {inner_domain} domain only created')
  
  page_titles_i = format_maps_page_title(outer_test_pth = NULL,
                                     outer_ref_pth = NULL,
                                     inner_test_pth = select_file_from_dir(TEST_INNER_DIR, fname = inner_file_tag),
                                     inner_ref_pth = select_file_from_dir(REF_INNER_DIR, fname = inner_file_tag),
                                     run_labels = str_c(RUN_LABELS, ' run')) %>%
  rep(length(comp_plots_list_i))
  #sort plots so that they show outer+inner followed by inner only for each var
  comp_plots_list = map(seq_along(comp_plots_list), ~c(comp_plots_list[.x], comp_plots_list_i[.x])) %>% 
    list_flatten()
  page_titles = map(seq_along(page_titles), ~c(page_titles[.x], page_titles_i[.x])) %>% 
    list_c()
}

#get domain dimensions for mapping
domain_dims = pmap(list(which = c('x', 'y')), st_get_dimension_values, comp_map_data[[1]][[1]][[1]]) %>% 
  lengths()

export = marrangeGrob(grobs = comp_plots_list, nrow = 1, ncol = 1, top = substitute(page_titles[g]))
ggsave(filename = path(maps_pth_out, COMP_MAPS_FNAME), export, paper = 'a4', height = 10, width = 7)
log_info('Comparison maps for the above variables in pdf format SAVED')
```

```{r comparison_maps_report, eval = PLOT_COMPARISON_MAPS, include=FALSE}
#for report
#create a table of vars in the comparison maps pdf plots
comp_maps_vars_tbl = comp_map_data[!null_vars_lgl] %>% 
  map(names) %>% 
  map(1) %>% 
  list_c() %>% 
  str_replace('_[^_]+$', '') %>% 
  categorise_emep_vars()

comp_maps_vars_tbl2 = comp_maps_vars_tbl %>% 
  gt() %>% 
  sub_missing(columns = everything(), missing_text = '') %>% 
  cols_label(emiss_vars = 'Emission Vars',
             surf_vars = 'Surface Conc Vars',
             dep_vars = 'Deposition Vars',
             misc_vars = 'Other Vars') %>% 
  tab_options(data_row.padding = px(3),
              #table.font.size = pct(95),
              table.align='left')

#create plots for vars in COMP_MAP_VARS_REPORT
report_map_vars = str_c(COMP_MAP_VARS_REPORT, collapse = '|')
report_plots_list = comp_plots_list[str_detect(names(comp_plots_list), report_map_vars)]
log_info('Comparison maps to be shown in the report created')

#check if any vars in COMP_MAP_VARS_REPORT are not plotted (i.e. not present in the EMEP output) and 
#remove from COMP_MAP_VARS_REPORT)
report_plots_vars = COMP_MAP_VARS_REPORT[map_lgl(COMP_MAP_VARS_REPORT, ~any(str_detect(names(comp_plots_list), .x)))]

if (length(setdiff(COMP_MAP_VARS_REPORT, report_plots_vars)) > 0) {
  log_warn('Variable {setdiff(COMP_MAP_VARS_REPORT, report_plots_vars)} requested for the report not available')
} 
map_headings = names(report_plots_list) %>%
  str_replace('_i$', ' (inner domain)')
  
for (i in seq_along(report_plots_list)) {
  report_plots_list[[i]] = report_plots_list[[i]] +
    theme(plot.margin = margin(5.5,5.5,4*5.5,5.5, "pt"))
}
```

``` {asis, echo = PLOT_COMPARISON_MAPS, eval = PLOT_COMPARISON_MAPS}
Comparison maps have been plotted for the following variables:
```

``` {r, eval = PLOT_COMPARISON_MAPS}
comp_maps_vars_tbl2
log_info('A list of vars for which comparison maps have been created printed in a table in the report')
```

``` {asis, echo = PLOT_COMPARISON_MAPS, eval = PLOT_COMPARISON_MAPS}
Maps for selected variables - *`r stringi::stri_replace_last_fixed(report_plots_vars, ', ', ' and ')`* - are shown below:
```

```{r plot_maps_report, echo=FALSE, eval = PLOT_COMPARISON_MAPS, fig.height=10 *(domain_dims[2]/domain_dims[1]*1.1), results='asis'}
for (i in seq_along(report_plots_list)) {
  cat('\n### ', map_headings[i], '\n')
  print(report_plots_list[[i]])
  cat('\n\n\n')
}
log_info('Comparison maps for requested vars plotted in the report')
```

```{r, eval = PLOT_COMPARISON_MAPS}
log_success('!!!PLOT_COMPARISON_MAPS task completed!!!')
log_layout(layout_blank)
log_separator(separator = ' ')
log_separator(separator = ' ')
```

```{r collate_mobs, include = F, echo = F, eval = COLLATE_MOBS}
log_layout(layout_glue)
log_with_separator('COLLATE_MOBS task', separator = '-')

#choose the inner domain run unless that's NA
obs_dir = ifelse(!is.null(TEST_INNER_DIR), TEST_INNER_DIR, TEST_OUTER_DIR)

#determine obs pollutants to be analysed
mobs_polls = OBSERVED_POLLS_EMEP_LINK[OBSERVED_POLLS] %>% 
  na.omit()

#get meta from emep run (handles both lonlat and PS)
nc = nc_open(str_subset(dir_ls(obs_dir), 'fullrun'))
mod_year = nc.get.time.series(nc) %>% 
  as_datetime() %>% 
  year()
nc_lon = ncvar_get(nc, "lon")
nc_lat = ncvar_get(nc, "lat")
nc_close(nc)

#determine network of automatic sites or read file with meta of custom measurements
if (length(AUTO_NETWORK[!file_exists(AUTO_NETWORK)]) > 0) {
  auto_sites = get_auto_meta(network = AUTO_NETWORK[!file_exists(AUTO_NETWORK)],
                             pollutant = names(mobs_polls), year = mod_year) %>%
    mutate(network = as.character(network)) %>% #must be a string for file_exists function
    mutate(year = mod_year, .after = poll_info) #just for info
} else auto_sites = NULL

if (length(AUTO_NETWORK[file_exists(AUTO_NETWORK)]) == 1) {
custom_sites = read_rds(AUTO_NETWORK[file_exists(AUTO_NETWORK)]) %>%
    mutate(poll = NA_character_) %>%
    nest(poll_info = c(poll))
} else custom_sites = NULL

sites_geo = bind_rows(auto_sites, custom_sites) %>%
  st_as_sf(coords = c('longitude', 'latitude'), crs = 4326)
log_info('Dataframe of obs sites (n = {nrow(sites_geo)}) created')

#get a 2D slice of the EMEP output to check if all sites are in the modelled domain
#loads quicker to check on the fullrun data
emep_slice = read_emep(str_subset(dir_ls(obs_dir), 'fullrun'),
                            emep_crs = TEST_CRS, var = mobs_polls[1], proxy = F) 
sites_in = get_sites_in_domain(sites_geo, emep_slice)

#log warning for sites outside the modelling domain
if (length(setdiff(unique(sites_geo$code), sites_in)) > 0) {
  log_warn('Site {setdiff(unique(sites_geo$code), sites_in)} is outside the model domain and will be ignored')
}

sites_geo = sites_geo %>%
  filter(code %in% sites_in) %>%
  mutate(longitude = st_coordinates(.)[ , 1],
         latitude = st_coordinates(.)[ , 2],
         .after = site_type_grp)

#get the 'x' and 'y' indexes for extracting data using ncdf4 functions
emep_indexes = future_pmap_dfr(list(longitude = sites_geo$longitude,
                                    latitude = sites_geo$latitude),
                               get_emep_indexes, str_subset(dir_ls(obs_dir), 'fullrun'), .options = furrr_options(seed = T))

sites_geo = sites_geo %>%
  mutate(i = emep_indexes$row,
         j = emep_indexes$col,
         .before = poll_info)
log_info('"i" and "j" indexes for obs sites extracted and added to the dataframe')

#write meta data to files - rds for further use and csv for easier human check
#check if Sites_used file already present and increase numbering if needed
sites_used_files = dir_ls(data_pth_out, regexp = '(S|s)ites.*\\.rds')
if (length(sites_used_files) == 0) {
  write_rds(sites_geo, path(data_pth_out, '00Sites_used.rds'))
  log_info("Obs sites written into {path(data_pth_out, '00Sites_used.rds')}")
} else {
  n = sites_used_files %>%
    path_file() %>%
    str_extract('\\d*') %>%
    as.integer() %>%
    max(na.rm = T) + 1
  n_string = n %>%
    str_pad(2, side = 'left', pad = '0')
  write_rds(sites_geo, path(data_pth_out, paste0(n_string,'Sites_used.rds')))
  log_info("Obs sites written into {path(data_pth_out, paste0(n_string,'Sites_used.rds'))}")
}

#create a dataframe for site-pollutant iteration (enables parallel processing using furrr)
iter_df = expand_grid(code = sites_geo$code, poll = names(mobs_polls)) %>%
  left_join(dplyr::select(sites_geo, code, network, i, j), by = 'code')

log_info('Mobs collating started')
#collate modelled and observed data to a list
mobs_tlist = future_pmap(list(site_code = iter_df$code,
                              i_index = iter_df$i,
                              j_index = iter_df$j,
                              network = iter_df$network,
                              var = iter_df$poll),
                         safely(collate_obs_mod_nc), nc_pth = str_subset(dir_ls(obs_dir), '(H|h)our'),
                         var_name_lookup = mobs_polls,
                         .options = furrr_options(seed = T)) %>%
  transpose()
log_info('Mobs collating finished')

# and filter successful outcomes
is_ok <- mobs_tlist$error %>%
  map_lgl(is_null)

if (sum(is_ok) == 0) {
  log_error('An ERROR occurred during mobs collation!')
}

#combine data per site
mobs_list = mobs_tlist$result[is_ok] %>%
  bind_rows() %>%
  split(.$code)

#convert to wide format for writing out to file (smaller file size)
mobs_wide = mobs_list %>%
  future_map(~pivot_wider(.x, id_cols = c(date, code), names_from = c(var), values_from = c(obs, mod)), .options = furrr_options(seed = T))

mobs_data_pths = path(data_pth_out, paste0(names(mobs_list), '_mod_obs'), ext = 'rds')
future_walk2(mobs_wide, mobs_data_pths, write_rds, .options = furrr_options(seed = T))
log_info('Mobs rds files SAVED')

```

```{r, eval = COLLATE_MOBS}
log_success('!!!COLLATE_MOBS task completed!!!')
log_layout(layout_blank)
log_separator(separator = ' ')
log_separator(separator = ' ')
```

``` {asis, echo = EVALUATE_MOBS || PLOT_MOBS || PLOT_MOBS_MAPS, eval = EVALUATE_MOBS || PLOT_MOBS || PLOT_MOBS_MAPS}
# Observations
```

```{r load_collated_mobs, eval = (EVALUATE_MOBS || PLOT_MOBS) && !COLLATE_MOBS}
log_info('Loading collated mobs data')
#choose the inner domain run unless that's NA
obs_dir = ifelse(!is.null(TEST_INNER_DIR), TEST_INNER_DIR, TEST_OUTER_DIR)

#determine obs pollutants to be analysed
mobs_polls = OBSERVED_POLLS_EMEP_LINK[OBSERVED_POLLS] %>% 
  na.omit()

#read saved meta data
sites_geo = map_dfr(dir_ls(data_pth_out, regexp = '(S|s)ites.*\\.rds'), read_rds) %>%
  distinct(code, .keep_all = T)
log_info('MOBS site metadata loaded')

#read saved mobs data
mobs_pths = dir_ls(data_pth_out, regexp = '\\.rds') %>%
  str_subset('(S|s)ites', negate = T)
mobs_list = future_map(mobs_pths, read_rds, .options = furrr_options(seed = T)) %>%
  future_map(mobs_to_long, .options = furrr_options(seed = T)) %>%
  #temporary to ensure code column is never NA due to a previous bug
  future_map(~mutate(.x, code = if_else(is.na(code), na.omit(unique(.$code)), code)), .options = furrr_options(seed = T))
log_info('MOBS data loaded')
```

```{r mobs_source_report_info, eval = (EVALUATE_MOBS || PLOT_MOBS)}
#format output string based on network/custom observation configuration
custom_lgl = file_exists(AUTO_NETWORK)
if (T %in% custom_lgl) {
  if (length(AUTO_NETWORK[!custom_lgl]) == 1) {
    network_string1 = paste0(str_to_upper(AUTO_NETWORK[!custom_lgl]),
                             ' automatic network and user provided data described in ',
                             AUTO_NETWORK[custom_lgl])
  } else {
    network_string0 = str_c(AUTO_NETWORK[!custom_lgl], collapse = ', ') %>% 
      str_to_upper() %>% 
      stringi::stri_replace_last_fixed(', ', ' and ')
      
    network_string1 = paste0(network_string0,
                             ' automatic networks and user provided data described in ',
                             AUTO_NETWORK[custom_lgl])
  }
} else {
    if (length(AUTO_NETWORK[!custom_lgl]) == 1) {
    network_string1 = paste0(str_to_upper(AUTO_NETWORK[!custom_lgl]),
                             ' automatic network')
  } else {
    network_string0 = str_c(AUTO_NETWORK[!custom_lgl], collapse = ', ') %>% 
      str_to_upper() %>% 
      stringi::stri_replace_last_fixed(', ', ' and ')
      
    network_string1 = paste0(network_string0,
                             ' automatic networks')
  }
}

mobs_vartbl = enframe(mobs_polls) %>% 
  mutate(name = gt_var_labeller[name]) %>% 
  gt() %>%
  cols_label(name = 'Species',
             value = 'EMEP Var') %>% 
  tab_options(data_row.padding = px(3),
                #table.font.size = pct(95),
                table.align='left') %>% 
  text_transform(location = cells_body(columns = name),
                 fn = function(x) {
                   str_replace_all(x, '\\[', "<sub>") %>% 
                     str_replace_all('\\]', "</sub>")
                 })
```

``` {asis, echo = (EVALUATE_MOBS || PLOT_MOBS), eval = (EVALUATE_MOBS || PLOT_MOBS)}
Hourly modelled concentrations have been compared with observations for the following species:
```

``` {r, eval = (EVALUATE_MOBS || PLOT_MOBS)}
mobs_vartbl
log_info('A link up table between OBS and EMEP var names printed in the report')
```

``` {asis, echo = (EVALUATE_MOBS || PLOT_MOBS), eval = (EVALUATE_MOBS || PLOT_MOBS)}
Observations have been taken from the `r network_string1`. A list of used sites and their meta data is saved in **Sites_used.rds** in the **Data** subdirectory. The location of the sites is shown in the map below.
```

``` {r plot_mobs_sites_map, eval = EVALUATE_MOBS || PLOT_MOBS, fig.width = 8.4}
if (is.null(MOBS_GROUPING_VAR)) {
  plot_mobs_sites_map2(sites_geo, basemap = MOBS_MAP_BASEMAP, legend_label = 'Monitoring Site', legend_title = NULL)
} else {
  plot_mobs_sites_map2(sites_geo, basemap = MOBS_MAP_BASEMAP, colours = MOBS_GROUPING_VAR_COLOURS,
                       group_column = MOBS_GROUPING_VAR, legend_title = 'Monitoring\nSite Type')
}

log_info('Map of all MOBS sites printed in the report')
```

```{r modStats, eval = (EVALUATE_MOBS || PLOT_MOBS)}

if ('ox' %in% OBSERVED_POLLS) {
  mobs_list = mobs_list %>%
    future_map(add_ox, df_format = 'long', units = OX_UNITS, .options = furrr_options(seed = T))
  log_info('Ox in {OX_UNITS} added to the data')
}

#WIP need to address different units for CO in aurn data
#if ('co' %in% OBSERVED_POLLS && network %in% c('aurn', 'saqn', 'waqn', 'aqe', 'nian') )

#calculate modstats for each site
test_mobs_stats = mobs_list %>% 
  future_map_dfr(calculate_modstats, modstats = MODSTATS_STATS, type = c('code', 'var')) %>% 
  group_by(var) 
#and save by 'var'
walk2(group_split(test_mobs_stats), pull(group_keys(test_mobs_stats)),
      ~write_csv(.x, file = path(tables_pth_out, str_glue('Mobs_modstats_{.y}'),ext = 'csv')))

test_mobs_ameans = mobs_list %>% 
  future_map_dfr(summarise_mobs, avg_time = 'year', data_thresh = MOBS_THRESHOLD,
                 .options = furrr_options(seed = T))
log_info('Annual means calculated')

test_mobs_astats = calculate_modstats(test_mobs_ameans, modstats = MODSTATS_STATS, type = c('var'))
if (!is.null(MOBS_GROUPING_VAR)) {
  test_mobs_astats = left_join(test_mobs_ameans, select(sites_geo, any_of(c('code', 'site', 'station', MOBS_GROUPING_VAR)))) %>% 
    calculate_modstats(modstats = MODSTATS_STATS, type = unique(c('var', MOBS_GROUPING_VAR))) %>% 
    bind_rows(test_mobs_astats) %>% 
    arrange(var) %>%
    relocate(all_of(MOBS_GROUPING_VAR), .after = var) %>% 
    mutate('{MOBS_GROUPING_VAR}' := if_else(is.na(.data[[MOBS_GROUPING_VAR]]), 'All', .data[[MOBS_GROUPING_VAR]]))
}
  
write_csv(test_mobs_astats, path(tables_pth_out, MOBS_STATS_FNAME))
log_info('Mobs statistics SAVED')

```

```{r mobs_report_stats_comp, eval = PLOT_MOBS && !is.null(REF_MOBS_DIR)}
ref_sites_geo = read_rds(dir_ls(REF_MOBS_DIR, regexp = '(S|s)ites.*\\.rds'))
ref_mobs_pths = dir_ls(REF_MOBS_DIR, regexp = '\\.rds') %>%
  str_subset('(S|s)ites', negate = T)
ref_mobs_list = future_map(ref_mobs_pths, read_rds, .options = furrr_options(seed = T)) %>%
  future_map(mobs_to_long, .options = furrr_options(seed = T)) %>%
  #temporary to ensure code column is never NA due to a previous bug
  future_map(~mutate(.x, code = if_else(is.na(code), na.omit(unique(.$code)), code)), .options = furrr_options(seed = T))
log_info('Reference MOBS data loaded')

ref_mobs_ameans = future_map_dfr(ref_mobs_list, summarise_mobs, avg_time = 'year', data_thresh = MOBS_THRESHOLD,
                             .options = furrr_options(seed = T))

log_info('Reference MOBS annual means calculated')

test_mobs_ameans2 = test_mobs_ameans %>% 
  filter(!is.na(obs)) %>% 
  select(code, var)
ref_mobs_ameans2 = ref_mobs_ameans %>% 
  filter(!is.na(obs)) %>% 
  select(code, var) 
both = inner_join(test_mobs_ameans2, ref_mobs_ameans2)
log_info('Test and ref MOBS annual means merged')

test_mobs_asub = semi_join(test_mobs_ameans, both, by = c('code', 'var')) %>% 
  calculate_modstats(modstats = MODSTATS_STATS, type = c('var')) %>% 
  select(-any_of(c('p', 'P'))) #remove significance level for this table
ref_mobs_asub = semi_join(ref_mobs_ameans, both, by = c('code', 'var')) %>%
  calculate_modstats(modstats = MODSTATS_STATS, type = c('var')) %>% 
  select(-any_of(c('p', 'P'))) #remove significance level for this table

both_stats = left_join(test_mobs_asub, ref_mobs_asub, by = c('var', 'n'), suffix = c('_test', '_ref'))
log_info('Model evaluations stats for test and ref MOBS annual means calculated')

```

``` {asis, echo = EVALUATE_MOBS, eval = EVALUATE_MOBS}
## Model Evaluation Stats
Model evaluation stats for all variables across all sites with data capture >= `r MOBS_THRESHOLD`% are shown in the table below.
```

```{r mobs_report_stats, eval = EVALUATE_MOBS}
#modstats table
test_mobs_astats %>% 
  mutate(var = gt_var_labeller[as.character(var)]) %>%
  gt() %>%
  tab_options(data_row.padding = px(3),
                #table.font.size = pct(95),
                table.align='left') %>% 
  cols_align(align = 'right',
             columns = -any_of(c('var', MOBS_GROUPING_VAR))) %>% 
  cols_align(align = 'left',
             columns = any_of(c('var', MOBS_GROUPING_VAR))) %>% 
  cols_label(var = 'Species') %>% 
  fmt_number(columns = any_of(c('FAC2', 'NMB', 'r')),
             decimals = 2) %>% 
  fmt_number(columns = any_of(c('MB', 'RMSE')),
             decimals = 1) %>% 
  text_transform(location = cells_body(columns = var),
                 fn = function(x) {
                   str_replace_all(x, '\\[', "<sub>") %>% 
                     str_replace_all('\\]', "</sub>")
                 }) %>% 
  sub_missing(missing_text = '-')

```

``` {asis, echo = EVALUATE_MOBS && nrow(both_stats) != 0, eval = EVALUATE_MOBS && nrow(both_stats) != 0}
The differences in model evaluation stats between the test and reference runs are shown in the table below. The difference has been calculated using only stations with data capture >= `r MOBS_THRESHOLD`% in both runs. The number of such sites is shown in the column labelled 'n'.
```

```{r mobs_report_comp, eval = EVALUATE_MOBS}

if (nrow(both_stats) != 0) {
    gt_stat_ordered = function(n) {
    #orders indexes for both_stats table
    o = c(1,2)
    out = vector('list', n)
    for (i in 1:n) {
      out[[i]] = c(2 + i, 2 + n + i )
    }
    o = c(o, list_c(out))
    } 
  
  both_stats %>% 
    .[gt_stat_ordered(length(MODSTATS_STATS) - 1)] %>% 
    mutate(var = gt_var_labeller[as.character(var)]) %>%
    gt() %>%
    tab_options(data_row.padding = px(3),
                table.align='left') %>% 
    cols_align(align = 'right',
               columns = -any_of(c('var', MOBS_GROUPING_VAR))) %>% 
    cols_align(align = 'left',
               columns = any_of(c('var', MOBS_GROUPING_VAR))) %>% 
    cols_label(var = 'Species') %>%
    fmt_number(columns = any_of(do.call(str_c, expand.grid(c('FAC2', 'NMB', 'r'), c('_test', '_ref')))),
               decimals = 2) %>% 
    fmt_number(columns = any_of(do.call(str_c, expand.grid(c('MB', 'RMSE'), c('_test', '_ref')))),
               decimals = 1) %>% 
    tab_spanner_delim(delim = '_') %>%
    text_transform(location = cells_body(columns = var),
                   fn = function(x) {
                     str_replace_all(x, '\\[', "<sub>") %>% 
                       str_replace_all('\\]', "</sub>")
                   })
    
}

```

```{r, eval = PLOT_MOBS}
log_layout(layout_glue)
log_with_separator('PLOT_MOBS task', separator = '-')
```

```{r plot_annual_scatter_plots, eval = PLOT_MOBS && EVALUATE_MOBS, fig.width = 8.4}
#this chunk plots annual means mobs scatter plots for sites with dc >= MOBS_THRESHOLD 
scatter_plots0 = test_mobs_ameans %>% 
  group_by(var)

if (!is.null(MOBS_GROUPING_VAR)) {
  scatter_plots = scatter_plots0 %>% 
    left_join(select(sites_geo, any_of(c('code', 'site', 'station', MOBS_GROUPING_VAR)))) %>% 
  group_split() %>% 
  map(plot_annual_scatter, colours = MOBS_GROUPING_VAR_COLOURS, group_column = MOBS_GROUPING_VAR, facet = F) %>% 
  set_names(pull(group_keys(scatter_plots0)))
} else {
  scatter_plots = scatter_plots0 %>% 
  group_split() %>% 
  map(plot_annual_scatter) %>% 
  set_names(pull(group_keys(scatter_plots0)))
}

scatter_plots = scatter_plots[order(match(names(scatter_plots), names(gt_var_labeller)))]
log_info('MOBS annual scatter plots created')

# 2 plots per page are hard coded, add blank plot if odd number of plots so that they are all the same size 
if (length(scatter_plots)%%2 !=0 ) {
  scatter_plots2 = c(scatter_plots, list(create_blank_plot()))
} else {
  scatter_plots2 = scatter_plots
}

#get EMEP run fname for title on pdf plots
run_info = format_maps_page_title(inner_test_pth = select_file_from_dir(obs_dir), run_labels = 'EMEP run')

scatter_plots_page_titles = rep(run_info, ceiling(length(scatter_plots2)/2))
export = marrangeGrob(grobs = scatter_plots2, nrow = 2 , ncol = 1, top = substitute(scatter_plots_page_titles[g]))
ggsave(filename = path(plots_pth_out, 'Annual_Mean_Scatter_all_sites.pdf'), export, paper = 'a4', height = 10, width = 7)
log_info('MOBS annual scatter plots SAVED')
```

``` {asis, echo = EVALUATE_MOBS && PLOT_MOBS, eval = EVALUATE_MOBS && PLOT_MOBS}
## Annual Mean Scatter Plots
Annual mean scatter plots calculated from all sites with data capture >= `r MOBS_THRESHOLD`%. Solid line represents 1:1 relationship, dashed lines 1:2 and 2:1 relationships, respectively.
```

``` {r plot_scatter_in_report, eval = EVALUATE_MOBS && PLOT_MOBS, fig.width = 8.4, results = 'asis'}
for (i in seq_along(scatter_plots)) {
  print(scatter_plots[[i]])
}
rm(scatter_plots2, scatter_plots, scatter_plots0, export)
```

``` {r, eval = EVALUATE_MOBS && PLOT_MOBS_MAPS, results = 'asis'}
cat('\n##', unname(MODSTATS_STATS_LOOKUP[MOBS_MAP_STAT]),'Maps\n')
cat('\nData calculated for sites with observation data capture >=', MOBS_THRESHOLD, '%.\n')
```

``` {r, eval = EVALUATE_MOBS && PLOT_MOBS_MAPS, fig.width = 8.4, results = 'asis'}
test_mobs_stats2 = test_mobs_stats %>% 
  ungroup() %>% 
  left_join(select(st_drop_geometry(sites_geo), 
                   any_of(c('code', 'station', 'site', 'elev(m)', 'latitude', 'longitude', 'call' ))), #for labels on the map
            by = 'code')
m_list0 = map(MOBS_MAP_VAR, ~filter(test_mobs_stats2, var == .x)) %>%
  keep(~nrow(.x) > 0)
if (length(m_list0) > 0) {
  m_list = m_list0 %>% 
      map(plot_mobs_stats_map, mobs_stat = MOBS_MAP_STAT[1], legend_title = MOBS_MAP_STAT[1])
  
  
  m_titles = map_chr(MOBS_MAP_VAR, ~gt_var_labeller[.x]) %>% 
    map_chr(.f = function(x) {
      str_replace_all(x, '\\[', "<sub>") %>% 
                     str_replace_all('\\]', "</sub>")
      }) %>% 
    map(~h3(HTML(.x)))
  
  htmltools::tagList(c(rbind(m_titles, m_list)))
    
}
```

```{r plot_mobs_tseries, eval = PLOT_MOBS}
#plot daily and hourly mobs per site
mobs_plotlist = mobs_list %>% 
  future_map(~mutate(.x, date = with_tz(date, tzone = MOBS_TZONE)), .options = furrr_options(seed = T)) %>% 
  future_map(format_mobs_to_plot, .options = furrr_options(seed = T)) %>% 
  future_map(left_join, select(st_drop_geometry(sites_geo), any_of(c('code', 'station', 'site', MOBS_GROUPING_VAR))), .options = furrr_options(seed = T))
  
mobs_plotlist %>% 
  future_walk(mobs_tseries_to_pdf, out_dir = dir_create(path(plots_pth_out, 'Individual_sites')),
              ppp = PPP, run_title_info = run_info, .options = furrr_options(seed = T))
log_info('MOBS tseries plots in pdf format SAVED')
names(mobs_plotlist) = mobs_plotlist %>% 
  map_chr(~pull(.x, code) %>% unique)
```

```{r mobs_report_selected_map, eval = PLOT_MOBS && length(MOBS_STATION_REPORT_TSERIES) > 0, results='asis'}
#select just sites that show time series in the report
if (all(is.character(MOBS_STATION_REPORT_TSERIES))) {
  sites_geo_map_sub = sites_geo %>% 
  filter(code %in% MOBS_STATION_REPORT_TSERIES)
} else if (all(is.numeric(MOBS_STATION_REPORT_TSERIES))) {
  sites_geo_map_sub = sites_geo %>% 
    filter(code %in% names(mobs_plotlist)[MOBS_STATION_REPORT_TSERIES])
}
```

```{r, eval = PLOT_MOBS && nrow(sites_geo_map_sub) != 0 && MOBS_STATION_REPORT_MAP == T, fig.width = 8.4, results = 'asis'}
cat('\n## Daily mean concentrations at selected sites\n\n')

if (is.null(MOBS_GROUPING_VAR)) {
  plot_mobs_sites_map2(sites_geo_map_sub, basemap = MOBS_MAP_BASEMAP, legend_label = 'Monitoring Site', legend_title = NULL)
} else {
  plot_mobs_sites_map2(sites_geo_map_sub, basemap = MOBS_MAP_BASEMAP, colours = MOBS_GROUPING_VAR_COLOURS,
                       group_column = MOBS_GROUPING_VAR, legend_title = 'Monitoring\nSite Type')
}

cat('\n\n\n')
log_info('Map of selected MOBS sites printed in the report')
```


```{r, mobs_report_plot_tseries, eval = PLOT_MOBS && nrow(sites_geo_map_sub) != 0, fig.width = 10, fig.height = 18, results ='asis'}
#add station codes to the list items so that stations for the report can be selected from mobs_list

report_mobs_plotlist = mobs_plotlist[MOBS_STATION_REPORT_TSERIES]  
log_info('MOBS data for selected sites extracted')

#check if all data available, print those missing
missing_mobs = setdiff(MOBS_STATION_REPORT_TSERIES, names(report_mobs_plotlist))

if (length(missing_mobs) > 0) {
  log_warn('Data for the requested site {missing_mobs} not available. The site is ignored')
}

#remove NULL tibbles from plotting
report_mobs_plotlist = compact(report_mobs_plotlist) %>% 
  future_map(~mutate(.x ,plots = map(data, plot_mobs_tseries),
              var = map(plots, names)),
      .options = furrr_options(seed = T)) %>% 
  map(ungroup) %>% 
  map(~filter(.x, month == -1)) %>% 
  map(unnest, cols = c(plots, var))

p_title_list = report_mobs_plotlist %>% 
  map(~str_c(unique(.x[['code']]),
             ' (',
             str_c(unique(.x[['site']]), unique(.x[['station']]), collapse = ''), #allow both site and station column name
             ')')) %>%  
  map(replace_non_ascii) %>% 
  map(str_replace_all, '\\.', '')

for (i in seq_along(names(report_mobs_plotlist))) {
  p_all = ggarrange(plotlist = report_mobs_plotlist[[i]]$plots, ncol = 1) #%>% 
    #annotate_figure(top = text_grob(p_title, size = 16, face = 'bold'))
  cat('\n\n\n### ', p_title_list[[i]], '\n')
  print(p_all)
  cat('\n\n\n')
}
log_info('Daily MOBS means for selected sites plotted in the report')
```

```{r, eval = PLOT_MOBS}
log_success('!!!PLOT_MOBS task completed!!!')
log_layout(layout_blank)
log_separator(separator = ' ')
log_separator(separator = ' ')
```


```{r, eval = T}
log_layout(layout_glue)
log_with_separator('ALL REQUESTED TASKS COMPLETED AND REPORT PRINTED', separator = '-', level = SUCCESS)
```
